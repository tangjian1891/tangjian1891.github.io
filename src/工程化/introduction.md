介绍工程化

## 传统开发

1. 前后端不分离时代。（jsp,.net,php）

   > 前端 html 页面，是请求的后端接口。接口返回的是一个 html 页面。页面由后端渲染或重定向。后端控制，前端与后端耦合度很高，路由控制权在后端。
   - 特点：
      - 路由：后端控制路由跳转展示的页面或重定向。
      - 页面：多页面
      - 资源部署位置：html，css，js 都放在了后端服务中。
   - 优点：
     - 全栈大佬一把梭。
   - 缺点：
     - 如果由原生 App 的需求，原生 App 可不要 HTML 页面，需要的是数据本身，为了对接 App，后端还需要再开发一套接口。
     - 切图仔开发页面，给到后端。导致前后端互相甩锅。

2. 前后端分离时代。
   分离后，后端仅返回前端需要的数据，而不是渲染的 html 页面。前端获得了路由的控制权。
   - 特点：
      - 路由：前端控制，hash跳转。
      - 页面：spa单页面
      - 资源部署位置：使用 nginx 部署静态资源，甚至放到云服务器，且使用 cdn 加速。
   - 优点:
     - 后端提供一套接口，供页面，App，第三方对接使用。
     - 与前端界限清晰，后端解耦，更加专注“高并发”，“高可用”，“高性能”。
   - 缺点：
     - 前端独立:从切图仔-》前端开发。

## 模块化
> 分解（认识）和聚合（改造）
函数->文件（问题）
1. 全局污染。（函数声明）
2. 依赖混乱。
解决文件问题-模块化：分解：隐藏内部实现细节，聚合：明确依赖关系。
CommonJs-运行时
ESM-编译时，运行前就确定依赖关系。
实现：
浏览器-esm
node-cjs,esm
构建工具： 基本上我们写的代码，都是给构建工具。

包管理：package,一系列模块得集合。 
node环境支持：npm(包得属性、registry、cli)
软件：gui（图形化操作界面）

前端：
语言，协议，环境，浏览器，框架/库,服务器，工程化



前端更好的使用工程化：
之前： 写好页面，对于兼容性，代码混淆，热更新 js 资源加时间戳。常常做的不够好。
现在： 前端工程化，对于源码，兼容性，自动加 hash，打包资源做的更好。

前端工程化：（基于 node）提升效率和质量。涵盖“测试”，“构建”，“部署”，“监控”

代码控制：git+prettier+eslint
测试：增加测试用例。
构建工具：代码兼容性，压缩混淆，自动 hash。
CI&CD：测试+部署集成到开发工作流中，减少发布风险，提高效率。
监控与调试：sentry 哨兵，埋点记录

restful 风格 api 设计。是 http 协议的最佳实践。充分利用 http 协议的各种功能。

1. 增删改查，对应 http 方法
   GET 查询资源 -安全的方法（只读）
   POST 新增资源
   PUT 更新资源 -幂等
   DELETE 删除资源 -幂等

> 幂等，数据概念。表达式 N 次变化与 1 次变化结果相关。计算机中，无论执行多少次，结果相同。

1. 一般设计如下，对于需要 PUT 和 DELETE 的资源，都给一个唯一标识符。
2. 后端对业务逻辑增加事务处理，保证状态一致性。

3. 资源参数放哪里，url 中，查询参数中，body 请求体。

4. http 状态码
   5 类:总共有 100 多种。
   1xx 相关操作
   2xx 操作成功
   3xx 重定向
   4xx 客户端错误
   5xx 服务器错误

实际使用:

1. 能使用 GET 和 POST 即可。
2. 不要将参数放到 url 中，接口有动词最好，否则使用第 1 点的 HTTP 方法辅助。 参数最好使用查询参数或请求体。前端 network 方便查询，查询参数有 key，方便知其意。

3. 返回状态码，2xx 统一使用 200，接口成功只认 200。其余状态码，都认为失败，使用错误信息提示。
