import{_ as a,v as e,b as t,R as o}from"./chunks/framework.caa0fbaf.js";const u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"book/js高程.md","filePath":"book/js高程.md"}'),r={name:"book/js高程.md"},s=o('<h2 id="变量赋值" tabindex="-1">变量赋值 <a class="header-anchor" href="#变量赋值" aria-label="Permalink to &quot;变量赋值&quot;">​</a></h2><p>const 变量 =  数据（string,number,boolean,null,undefined） const 变量 =  数据(object,array,date) 变量中存储的“值”：分为(真实数据值)(引用地址值/指针) 如果数据是基本类型:变量的值-》(值)真实数据值 如果数据是引用类型：变量的值-》(值)引用地址值/指针  -》（根据地址值去堆内存中找）真实数据值</p><p>赋值操作: 基本类型是赋值是复制一份真实数据，所以两份数据互不影响。TIP:互不影响，所以基本上类型自带(深克隆)。 引用类型赋值是复制引用地址值，新旧变量指向的对象为同一个。</p><p>函数参数： 传递的是值传递,叫赋值传递也比较好理解。js与java都遵循函数参数值传递。 <a href="https://blog.csdn.net/weixin_34233974/article/details/117056264" target="_blank" rel="noreferrer">c语言函数参数方式-值传递、指针传递、引用传递</a> 引用传递:在c语言里面，我传递A的引用。函数里把A改成B，那么外面的A也就变成B了。但是这个特性js、java都做不到呀</p><p>克隆:复制数据。 对引用类型来说，以对象和数组举例。 浅克隆:新的对象拥有原始对象的第一层属性的拷贝。新对象和原始对象的引用地址值不同，所以新旧对象是两个不同的对象。但是对象内部属性的引用类型属性是相同的。 深克隆:在浅克隆基础上。对象内部属性都与原始对象无关。 递归克隆。</p><h2 id="_10-函数" tabindex="-1">10.函数 <a class="header-anchor" href="#_10-函数" aria-label="Permalink to &quot;10.函数&quot;">​</a></h2><h3 id="_10-函数定义" tabindex="-1">10.函数定义 <a class="header-anchor" href="#_10-函数定义" aria-label="Permalink to &quot;10.函数定义&quot;">​</a></h3><blockquote><p>函数也是对象，函数实际上是Function类的实例对象。</p></blockquote><h3 id="_10-1函数声明提升" tabindex="-1">10.1函数声明提升 <a class="header-anchor" href="#_10-1函数声明提升" aria-label="Permalink to &quot;10.1函数声明提升&quot;">​</a></h3><p>js引擎在执行任何代码时，会先读取函数声明并生成函数定义。函数表达式只能在代码执行到那一行，才能生成函数定义。</p>',10),n=[s];function i(l,c,d,h,_,p){return e(),t("div",null,n)}const f=a(r,[["render",i]]);export{u as __pageData,f as default};
